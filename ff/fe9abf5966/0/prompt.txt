using agent teams, investigate in detail the backend and frontend. Then determine whether there any gaps/functionality that requires bridging between the two

---

Base directory for this skill: /Users/jdsingh/.claude/plugins/cache/claude-plugins-official/superpowers/4.3.1/skills/dispatching-parallel-agents

# Dispatching Parallel Agents

## Overview

When you have multiple unrelated failures (different test files, different subsystems, different bugs), investigating them sequentially wastes time. Each investigation is independent and can happen in parallel.

**Core principle:** Dispatch one agent per independent problem domain. Let them work concurrently.

## When to Use

```dot
digraph when_to_use {
    "Multiple failures?" [shape=diamond];
    "Are they independent?" [shape=diamond];
    "Single agent investigates all" [shape=box];
    "One agent per problem domain" [shape=box];
    "Can they work in parallel?" [shape=diamond];
    "Sequential agents" [shape=box];
    "Parallel dispatch" [shape=box];

    "Multiple failures?" -> "Are they independent?" [label="yes"];
    "Are they independent?" -> "Single agent investigates all" [label="no - related"];
    "Are they independent?" -> "Can they work in parallel?" [label="yes"];
    "Can they work in parallel?" -> "Parallel dispatch" [label="yes"];
    "Can they work in parallel?" -> "Sequential agents" [label="no - shared state"];
}
```

**Use when:**
- 3+ test files failing with different root causes
- Multiple subsystems broken independently
- Each problem can be understood without context from others
- No shared state between investigations

**Don't use when:**
- Failures are related (fix one might fix others)
- Need to understand full system state
- Agents would interfere with each other

## The Pattern

### 1. Identify Independent Domains

Group failures by what's broken:
- File A tests: Tool approval flow
- File B tests: Batch completion behavior
- File C tests: Abort functionality

Each domain is independent - fixing tool approval doesn't affect abort tests.

### 2. Create Focused Agent Tasks

Each agent gets:
- **Specific scope:** One test file or subsystem
- **Clear goal:** Make these tests pass
- **Constraints:** Don't change other code
- **Expected output:** Summary of what you found and fixed

### 3. Dispatch in Parallel

```typescript
// In Claude Code / AI environment
Task("Fix agent-tool-abort.test.ts failures")
Task("Fix batch-completion-behavior.test.ts failures")
Task("Fix tool-approval-race-conditions.test.ts failures")
// All three run concurrently
```

### 4. Review and Integrate

When agents return:
- Read each summary
- Verify fixes don't conflict
- Run full test suite
- Integrate all changes

## Agent Prompt Structure

Good agent prompts are:
1. **Focused** - One clear problem domain
2. **Self-contained** - All context needed to understand the problem
3. **Specific about output** - What should the agent return?

```markdown
Fix the 3 failing tests in src/agents/agent-tool-abort.test.ts:

1. "should abort tool with partial output capture" - expects 'interrupted at' in message
2. "should handle mixed completed and aborted tools" - fast tool aborted instead of completed
3. "should properly track pendingToolCount" - expects 3 results but gets 0

These are timing/race condition issues. Your task:

1. Read the test file and understand what each test verifies
2. Identify root cause - timing issues or actual bugs?
3. Fix by:
   - Replacing arbitrary timeouts with event-based waiting
   - Fixing bugs in abort implementation if found
   - Adjusting test expectations if testing changed behavior

Do NOT just increase timeouts - find the real issue.

Return: Summary of what you found and what you fixed.
```

## Common Mistakes

**❌ Too broad:** "Fix all the tests" - agent gets lost
**✅ Specific:** "Fix agent-tool-abort.test.ts" - focused scope

**❌ No context:** "Fix the race condition" - agent doesn't know where
**✅ Context:** Paste the error messages and test names

**❌ No constraints:** Agent might refactor everything
**✅ Constraints:** "Do NOT change production code" or "Fix tests only"

**❌ Vague output:** "Fix it" - you don't know what changed
**✅ Specific:** "Return summary of root cause and changes"

## When NOT to Use

**Related failures:** Fixing one might fix others - investigate together first
**Need full context:** Understanding requires seeing entire system
**Exploratory debugging:** You don't know what's broken yet
**Shared state:** Agents would interfere (editing same files, using same resources)

## Real Example from Session

**Scenario:** 6 test failures across 3 files after major refactoring

**Failures:**
- agent-tool-abort.test.ts: 3 failures (timing issues)
- batch-completion-behavior.test.ts: 2 failures (tools not executing)
- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)

**Decision:** Independent domains - abort logic separate from batch completion separate from race conditions

**Dispatch:**
```
Agent 1 → Fix agent-tool-abort.test.ts
Agent 2 → Fix batch-completion-behavior.test.ts
Agent 3 → Fix tool-approval-race-conditions.test.ts
```

**Results:**
- Agent 1: Replaced timeouts with event-based waiting
- Agent 2: Fixed event structure bug (threadId in wrong place)
- Agent 3: Added wait for async tool execution to complete

**Integration:** All fixes independent, no conflicts, full suite green

**Time saved:** 3 problems solved in parallel vs sequentially

## Key Benefits

1. **Parallelization** - Multiple investigations happen simultaneously
2. **Focus** - Each agent has narrow scope, less context to track
3. **Independence** - Agents don't interfere with each other
4. **Speed** - 3 problems solved in time of 1

## Verification

After agents return:
1. **Review each summary** - Understand what changed
2. **Check for conflicts** - Did agents edit same code?
3. **Run full suite** - Verify all fixes work together
4. **Spot check** - Agents can make systematic errors

## Real-World Impact

From debugging session (2025-10-03):
- 6 failures across 3 files
- 3 agents dispatched in parallel
- All investigations completed concurrently
- All fixes integrated successfully
- Zero conflicts between agent changes

---

<teammate-message teammate_id="backend-investigator" color="blue" summary="Comprehensive Forge backend investigation complete">
## Forge Rust Backend Investigation — Complete Report

I've conducted a thorough investigation of the entire Forge Rust backend. Here are my complete findings:

### API Endpoints (All paths prefixed with `/api/` except `/health`)

**Project Management:**
- `GET /api/projects` — List all projects. Returns: `Vec<Project>`
- `POST /api/projects` — Create project. Body: `CreateProjectRequest {name, path}`. Returns: `Project` (201 Created)
- `POST /api/projects/clone` — Clone GitHub repo. Body: `CloneProjectRequest {repo_url}`. Returns: `Project`
- `GET /api/projects/:id` — Get project details. Returns: `Project`
- `GET /api/projects/:id/board` — Get Kanban board state. Returns: `BoardView { project, columns: Vec<ColumnView> }`
- `POST /api/projects/:id/sync-github` — Sync issues from GitHub. Returns: `SyncResult {imported, skipped, total_github}`

**Issue Management:**
- `POST /api/projects/:id/issues` — Create issue. Body: `CreateIssueRequest {title, description?, column?}`. Returns: `Issue` (201 Created)
- `GET /api/issues/:id` — Get issue detail with full run history. Returns: `IssueDetail {issue, runs: Vec<PipelineRunDetail>}`
- `PATCH /api/issues/:id` — Update issue. Body: `UpdateIssueRequest {title?, description?}`. Returns: `Issue`
- `DELETE /api/issues/:id` — Delete issue. Returns: 204 No Content
- `PATCH /api/issues/:id/move` — Move to column/position. Body: `MoveIssueRequest {column, position}`. Returns: `Issue`. **Triggers pipeline on InProgress**

**Pipeline Execution:**
- `POST /api/issues/:id/run` — Trigger pipeline manually. Returns: `PipelineRun`
- `GET /api/runs/:id` — Get pipeline run status. Returns: `PipelineRun`
- `POST /api/runs/:id/cancel` — Cancel running pipeline. Returns: `PipelineRun`

**Agent Team Execution:**
- `GET /api/runs/:id/team` — Get agent team + all tasks. Returns: `AgentTeamDetail {team: AgentTeam, tasks: Vec<AgentTask>}`
- `GET /api/tasks/:id/events` — Get agent task events (thinking/action/output/signal). Returns: `Vec<AgentEvent>`

**GitHub OAuth:**
- `GET /api/github/status` — Get auth status. Returns: `GitHubAuthStatus {connected, client_id_configured}`
- `POST /api/github/device-code` — Initiate device flow. Returns: `{device_code, user_code, verification_uri, expires_in}`
- `POST /api/github/poll` — Poll device code. Body: `PollTokenRequest {device_code}`. Returns: `{access_token}` or error
- `POST /api/github/connect` — Connect with PAT token. Body: `ConnectTokenRequest {token}`. Returns: 204 No Content
- `GET /api/github/repos` — List user's GitHub repos. Returns: `Vec<{name, owner, url}>`
- `POST /api/github/disconnect` — Remove GitHub token. Returns: 204 No Content

**Assets & Health:**
- `GET /api/screenshots/*path` — Serve screenshot files from agent verification
- `GET /health` — Liveness probe. Returns: 200 OK

---

### WebSocket Messages (JSON format: `{type, data}`)

**Issue Lifecycle:**
- `IssueCreated {issue: Issue}` — New issue created
- `IssueUpdated {issue: Issue}` — Issue fields changed
- `IssueMoved {issue_id, from_column, to_column, position}` — Issue dragged between columns
- `IssueDeleted {issue_id}` — Issue removed
- `ProjectCreated {project: Project}` — New project created

**Pipeline Lifecycle:**
- `PipelineStarted {run: PipelineRun}` — Run created, status = Queued
- `PipelineProgress {run_id, phase, iteration, percent?}` — Progress update
- `PipelinePhaseStarted {run_id, phase_number, phase_name, wave}` — Phase begins
- `PipelinePhaseCompleted {run_id, phase_number, success}` — Phase terminal state
- `PipelineReviewStarted {run_id, phase_number}` — Review specialists activated
- `PipelineReviewCompleted {run_id, phase_number, passed, findings_count}` — Review results
- `PipelineBranchCreated {run_id, branch_name}` — Git branch created
- `PipelinePrCreated {run_id, pr_url}` — Pull request opened
- `PipelineCompleted {run: PipelineRun}` — Run succeeded (terminal)
- `PipelineFailed {run: PipelineRun}` — Run failed (terminal)
- `PipelineError {run_id, message}` — Error event

**Agent Team Execution:**
- `TeamCreated {run_id, team_id, strategy: ExecutionStrategy, isolation: IsolationStrategy, plan_summary, tasks: Vec<AgentTask>}`
  - Strategies: `parallel`, `sequential`, `wave_pipeline`, `adaptive`
  - Isolation: `worktree`, `container`, `hybrid`, `shared`
- `WaveStarted {run_id, team_id, wave, task_ids: Vec<i64>}`
- `WaveCompleted {run_id, team_id, wave, success_count, failed_count}`
- `MergeStarted {run_id, wave}` — Merging task branches after wave
- `MergeCompleted {run_id, wave, conflicts}` — Merge done
- `MergeConflict {run_id, wave, files: Vec<String>}` — Conflict list

**Agent Task Lifecycle:**
- `AgentTaskStarted {run_id, task_id, name, role: AgentRole, wave}`
  - Roles: `coder`, `tester`, `reviewer`, `planner`, `browser_verifier`, `test_verifier`
- `AgentTaskCompleted {run_id, task_id, success}`
- `AgentTaskFailed {run_id, task_id, error}`

**Agent Streaming Events:**
- `AgentThinking {run_id, task_id, content}` — Internal reasoning
- `AgentAction {run_id, task_id, action_type, summary, metadata: JSON}` — Concrete action (file edit, command, etc.)
- `AgentOutput {run_id, task_id, content}` — Substantive output (code, test results)
- `AgentSignal {run_id, task_id, signal_type: SignalType, content}`
  - Signal types: `progress`, `blocker`, `pivot`

**Verification:**
- `VerificationResult {run_id, task_id, verification_type: VerificationType, passed, summary, screenshots: Vec<String>, details: JSON}`
  - Verification types: `browser`, `test_build`

---

### Database Schema (SQLite)

**Tables:**

1. **projects**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `name` TEXT NOT NULL
   - `path` TEXT NOT NULL (filesystem path)
   - `github_repo` TEXT (owner/repo)
   - `created_at` TEXT (ISO 8601, default now)

2. **issues**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `project_id` INT FK → projects.id ON DELETE CASCADE
   - `title` TEXT NOT NULL
   - `description` TEXT DEFAULT ''
   - `column_name` TEXT DEFAULT 'backlog' (backlog|ready|in_progress|in_review|done)
   - `position` INT DEFAULT 0 (sort order within column)
   - `priority` TEXT DEFAULT 'medium' (low|medium|high|critical)
   - `labels` TEXT DEFAULT '[]' (JSON array of strings)
   - `github_issue_number` INT (optional, linked GitHub issue)
   - `created_at` TEXT DEFAULT now
   - `updated_at` TEXT DEFAULT now
   - **Indexes:** `idx_issues_project(project_id)`, `idx_issues_column(project_id, column_name)`, `idx_issues_github_number(project_id, github_issue_number) UNIQUE WHERE github_issue_number IS NOT NULL`

3. **pipeline_runs**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `issue_id` INT FK → issues.id ON DELETE CASCADE
   - `status` TEXT DEFAULT 'queued' (queued|running|completed|failed|cancelled)
   - `phase_count` INT (total phases, once known)
   - `current_phase` INT (1-based)
   - `iteration` INT (current iteration in active phase)
   - `summary` TEXT (success summary)
   - `error` TEXT (failure message)
   - `branch_name` TEXT (git branch, e.g., forge/issue-42-title)
   - `pr_url` TEXT (GitHub PR URL)
   - `team_id` INT FK → agent_teams.id (for agent-team mode)
   - `has_team` INT DEFAULT 0 (boolean: 0=single forge pipeline, 1=agent team execution)
   - `started_at` TEXT DEFAULT now
   - `completed_at` TEXT (terminal state only)
   - **Index:** `idx_pipeline_runs_issue(issue_id)`

4. **pipeline_phases**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `run_id` INT FK → pipeline_runs.id ON DELETE CASCADE
   - `phase_number` TEXT NOT NULL (e.g., "1", "2.1")
   - `phase_name` TEXT NOT NULL
   - `status` TEXT DEFAULT 'pending' (pending|running|completed|failed)
   - `iteration` INT (current retry count)
   - `budget` INT (max iterations allowed)
   - `started_at` TEXT (phase start time)
   - `completed_at` TEXT (terminal state)
   - `error` TEXT (failure reason)
   - **Unique:** `(run_id, phase_number)`
   - **Index:** `idx_pipeline_phases_run(run_id)`

5. **agent_teams**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `run_id` INT FK → pipeline_runs.id
   - `strategy` TEXT NOT NULL (parallel|sequential|wave_pipeline|adaptive)
   - `isolation` TEXT NOT NULL (worktree|container|hybrid|shared)
   - `plan_summary` TEXT DEFAULT '' (planner's reasoning)
   - `created_at` TEXT DEFAULT now

6. **agent_tasks**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `team_id` INT FK → agent_teams.id
   - `name` TEXT NOT NULL
   - `description` TEXT DEFAULT ''
   - `agent_role` TEXT DEFAULT 'coder' (coder|tester|reviewer|planner|browser_verifier|test_verifier)
   - `wave` INT DEFAULT 0 (execution group; parallel within wave, sequential between waves)
   - `depends_on` TEXT DEFAULT '[]' (JSON array of task IDs from earlier waves)
   - `status` TEXT DEFAULT 'pending' (pending|running|completed|failed|cancelled)
   - `isolation_type` TEXT DEFAULT 'shared' (worktree|container|hybrid|shared)
   - `worktree_path` TEXT (git worktree directory if using worktree isolation)
   - `container_id` TEXT (Docker container ID if using container isolation)
   - `branch_name` TEXT (git branch for this task)
   - `started_at` TEXT
   - `completed_at` TEXT
   - `error` TEXT

7. **agent_events**
   - `id` INT PRIMARY KEY AUTOINCREMENT
   - `task_id` INT FK → agent_tasks.id
   - `event_type` TEXT NOT NULL (thinking|action|output|signal|error)
   - `content` TEXT DEFAULT ''
   - `metadata` TEXT (JSON, present for Signal events)
   - `created_at` TEXT DEFAULT now

8. **settings** (key-value store)
   - `key` TEXT PRIMARY KEY
   - `value` TEXT NOT NULL
   - `updated_at` TEXT DEFAULT now
   - Used to store: `github_token` (persisted across restarts)

---

### Models & Enums

**PipelineStatus** (state machine):
- `Queued` → `Running` → `Completed` | `Failed` | `Cancelled` (terminal)
- Method: `is_terminal()` returns true for terminal states

**IssueColumn** (Kanban workflow):
- `Backlog` → `Ready` → `InProgress` → `InReview` → `Done`
- Moving to `InProgress` triggers `PipelineRunner::run_pipeline()`

**Priority**:
- `Low`, `Medium`, `High`, `Critical`

**ExecutionStrategy** (how tasks are scheduled):
- `Parallel` — all tasks start simultaneously
- `Sequential` — one at a time in dependency order
- `WavePipeline` — tasks in waves; wave N completes before N+1 starts
- `Adaptive` — reserved for future

**IsolationStrategy** (filesystem isolation per task):
- `Worktree` — each task gets a `git worktree` branch from `main`; merged after wave
- `Container` — Docker container (reserved)
- `Hybrid` — container + worktree (reserved)
- `Shared` — all tasks share same directory

**AgentRole** (task assignment):
- `Coder` — writes implementation
- `Tester` — writes & runs tests
- `Reviewer` — code review
- `Planner` — creates team plan (system-assigned)
- `BrowserVerifier`, `TestVerifier` — future verification roles

**AgentTaskStatus**:
- `Pending` → `Running` → `Completed` | `Failed` | `Cancelled` (terminal)

**SignalType** (structured signals from agents):
- `Progress` — resets stall detector
- `Blocker` — obstacle preventing continuation
- `Pivot` — changing approach

**VerificationType**:
- `Browser` — headless browser verification
- `TestBuild` — run test suite

---

### Pipeline Execution Flow

**Issue → Pipeline → Completion:**

1. **Issue Moved to InProgress** → `PATCH /api/issues/:id/move` with `column: "in_progress"`
2. **Pipeline Created** → DB creates `PipelineRun` (status=Queued), broadcasts `PipelineStarted`
3. **Git Branch Created** → `create_git_branch()` → `forge/issue-{id}-{slug}`
4. **Planner Called** → `Planner::plan(title, description, labels)` → `PlanResponse`
   - Returns: `{ strategy, isolation, reasoning, tasks: Vec<PlanTask>, skip_visual_verification }`
   - Plan validation checks: strategy/role/isolation values, dependency ordering
5. **Agent Team Created** (if multi-task plan) → DB stores `AgentTeam` + `AgentTask` records
   - Broadcasts `TeamCreated` with task list
6. **Wave Execution** (if using `WavePipeline` strategy):
   - For each wave `N`:
     - Broadcasts `WaveStarted {wave, task_ids}`
     - For each task in wave (parallel):
       - Creates worktree (if `isolation_type=Worktree`)
       - Broadcasts `AgentTaskStarted`
       - Spawns agent (local process or Docker container)
       - Streams output lines → parses as `AgentEvent` → persists to DB + broadcasts
       - Broadcasts `AgentTaskCompleted` or `AgentTaskFailed`
     - After all tasks complete: merges worktrees into base branch (`merge_waves()`)
     - Broadcasts `MergeCompleted`
7. **Pipeline Fallback** (if plan is single-task sequential):
   - Falls back to classic `forge` CLI execution instead of agent team
8. **Post-Completion:**
   - Creates pull request via `gh pr create`
   - Broadcasts `PipelinePrCreated`
   - Auto-promotes issue: `Done` if clean, `InReview` if warnings, stays as-is if failed
   - Broadcasts `PipelineCompleted` or `PipelineFailed`
9. **Cleanup** on cancel/shutdown: kills child processes or stops Docker containers

---

### Key Components

**PipelineRunner** (`pipeline.rs`):
- Tracks running child processes by `run_id`
- Uses `GitLockMap` to serialize per-project git operations
- Methods:
  - `run_pipeline()` — orchestrates full execution
  - `execute_agent_team()` — multi-task execution
  - `cancel()` — kill process, update DB, move issue back to Ready
  - `shutdown()` — graceful cleanup on server stop

**DbHandle** (`db.rs`):
- Async-safe wrapper around `FactoryDb`
- Runs all SQLite access on tokio blocking thread pool
- Methods: `call()` (async), `lock_sync()` (tests/startup only)

**AgentExecutor** (`agent_executor.rs`):
- Runs individual agent tasks
- Spawns subprocess or Docker container
- Streams output, parses events, persists to DB

**Planner** (`planner.rs`):
- Decomposes issue into parallelizable tasks
- LLM-based (Claude) with system prompt
- Returns structured `PlanResponse` (JSON validated)

**DockerSandbox** (`sandbox.rs`):
- Optional Docker isolation for pipeline execution
- Enabled via `FORGE_SANDBOX=true` environment variable
- Prunes stale containers on startup

---

### Environment Variables & Configuration

**ServerConfig** (from `server.rs::ServerConfig`):
- `port` — default 3141
- `db_path` — default `.forge/factory.db`
- `project_path` — default "."
- `dev_mode` — enables CORS (0.0.0.0 binding)

**Environment Variables:**
- `GITHUB_CLIENT_ID` — OAuth client ID (read at startup)
- `FORGE_SANDBOX` — set to "true" to enable Docker sandboxing
- Persisted to DB: `github_token` stored in `settings` table, restored on startup

**Server Startup** (`server.rs::start_server`):
1. Ensures `.forge/` directory exists
2. Initializes SQLite DB with schema & migrations
3. Loads persisted `github_token` from settings
4. Optionally initializes Docker sandbox
5. Binds to `127.0.0.1:3141` (or `0.0.0.0:3141` in dev mode)
6. Serves static SPA from embedded React UI (fallback to index.html for client routing)

---

### Architecture Highlights

**WebSocket Broadcasting:**
- Central `broadcast::Sender<String>` in `AppState`
- Events serialized as JSON `WsMessage` enum
- Ping/pong keepalive every 30s; timeout after 60s
- Clients auto-subscribe via `/ws` upgrade

**Git Safety:**
- `GitLockMap` serializes per-project git mutations
- Long-running agent execution remains parallel
- Only short git commands (checkout, merge, push) are locked

**Database Async Pattern:**
- All DB access runs on tokio blocking thread pool
- Prevents synchronous SQLite I/O from blocking async worker threads
- Used in hot paths like event broadcasting

**Phase Progress Parsing:**
- Pipeline stdout lines parsed as JSON `ProgressInfo { phase, phase_count, iteration }`
- Broadcast to UI in real time via WebSocket

---

### Error Handling

**FactoryError** enum:
- `ProjectNotFound {id}` → 404
- `IssueNotFound {id}` → 404
- `RunNotFound {id}` → 404
- `InvalidColumn {column, message}` → 400
- `PipelineAlreadyRunning {issue_id}` → 400
- `LockPoisoned` → 500
- `BadRequest(msg)` → 400
- `GitHub(msg)` → 500
- `Database(e)` → 500
- `Other(e)` → 500

---

### Auto-Promotion Policy

After pipeline completion, issues auto-move based on results:
- **Done** — clean run, no warnings, no arbiter PROCEED
- **InReview** — warnings/findings/fix attempts needed
- **Failed** — pipeline error (stays as-is)

---

This backend exposes a complete self-implementing Kanban system with agent team execution, GitHub integration, and real-time WebSocket progress tracking.
</teammate-message>

---

<teammate-message teammate_id="backend-investigator" color="blue">
{"type":"idle_notification","from":"backend-investigator","timestamp":"2026-02-26T19:45:58.477Z","idleReason":"available"}
</teammate-message>

<teammate-message teammate_id="frontend-investigator" color="green" summary="Comprehensive React frontend investigation report complete">
## Forge React Frontend - Comprehensive Investigation Report

I have completed a thorough investigation of the Forge React frontend (`ui/src/`). Here is the complete analysis:

---

### PROJECT STRUCTURE & CONFIGURATION

**Package Manager & Build:**
- Vite 7.3.1 as build tool
- React 19.2.0, React DOM 19.2.0
- TypeScript 5.9.3
- Tailwind CSS 4.2.0 with Vite plugin
- Testing: Vitest 4.0.18, RTL 16.3.2, MSW 2.12.10 for API mocking
- Drag-drop: @dnd-kit core, sortable, utilities

**Vite Config (`ui/vite.config.ts`):**
- Dev server proxies `/api` → `http://localhost:3141` (configurable via `API_HOST` env)
- Dev server proxies `/ws` → `ws://localhost:3141` (WebSocket support)
- Output: `dist/` directory

---

### API CLIENT (`ui/src/api/client.ts`)

**Base URL:** `/api` (proxied to backend during dev)

**All HTTP Endpoints:**

| Method | Path | Request Body | Response Type | Notes |
|--------|------|--------------|---------------|-------|
| GET | `/projects` | — | `Project[]` | List all projects |
| POST | `/projects` | `{ name, path }` | `Project` | Create new project |
| POST | `/projects/clone` | `{ repo_url }` | `Project` | Clone from GitHub URL |
| GET | `/projects/{id}` | — | `Project` | Get single project |
| GET | `/projects/{id}/board` | — | `BoardView` | Fetch full board state |
| POST | `/projects/{id}/issues` | `{ title, description, column? }` | `Issue` | Create issue in column (default: backlog) |
| GET | `/issues/{id}` | — | `IssueDetail` | Get issue with all pipeline runs |
| PATCH | `/issues/{id}` | `{ title?, description? }` | `Issue` | Update issue title/description |
| PATCH | `/issues/{id}/move` | `{ column, position }` | `Issue` | Move issue to column at position |
| DELETE | `/issues/{id}` | — | void (204) | Delete issue |
| POST | `/issues/{id}/run` | — | `PipelineRun` | Trigger pipeline for issue |
| GET | `/runs/{id}` | — | `PipelineRun` | Get pipeline run status |
| POST | `/runs/{id}/cancel` | — | `PipelineRun` | Cancel running pipeline |
| GET | `/runs/{id}/team` | — | `AgentTeamDetail` | Get team + tasks for a run |
| GET | `/tasks/{id}/events?limit={limit}` | — | `AgentEvent[]` | Get events for a task (default limit: 100) |
| POST | `/github/status` | — | `GitHubAuthStatus` | Check GitHub connection status |
| POST | `/github/device-code` | — | `GitHubDeviceCode` | Start OAuth device flow |
| POST | `/github/poll` | `{ device_code }` | `{ status: 'pending'\|'complete' }` | Poll for token completion |
| POST | `/github/connect` | `{ token }` | `{ status }` | Connect with PAT |
| GET | `/github/repos` | — | `GitHubRepo[]` | List connected GitHub repos |
| POST | `/github/disconnect` | — | `{ status }` | Disconnect GitHub |
| POST | `/projects/{id}/sync-github` | — | `SyncResult` | Sync issues from GitHub |

**Error Handling:** `request()` throws on non-2xx status, includes response text in error message.

---

### WEBSOCKET HANDLING

**Connection URL:** `ws://{window.location.host}/ws` (constructed in App.tsx)

**Message Types (Discriminated Union in `types/index.ts`, lines 129-158):**

**Issue Events:**
- `IssueCreated`: `{ issue }` - New issue added
- `IssueUpdated`: `{ issue }` - Issue title/description changed
- `IssueMoved`: `{ issue_id, from_column, to_column, position }` - Drag-drop update
- `IssueDeleted`: `{ issue_id }` - Issue removed

**Pipeline Execution:**
- `PipelineStarted`: `{ run }` - Pipeline triggered
- `PipelineProgress`: `{ run_id, phase, iteration, percent }` - Phase/iteration progress
- `PipelineCompleted`: `{ run }` - Pipeline succeeded
- `PipelineFailed`: `{ run }` - Pipeline failed
- `PipelineBranchCreated`: `{ run_id, branch_name }` - Git branch created
- `PipelinePrCreated`: `{ run_id, pr_url }` - PR created (links to GitHub)

**Phases & Reviews:**
- `PipelinePhaseStarted`: `{ run_id, phase_number, phase_name, wave }` - Phase begins
- `PipelinePhaseCompleted`: `{ run_id, phase_number, success }` - Phase ends
- `PipelineReviewStarted`: `{ run_id, phase_number }` - Review gate opened
- `PipelineReviewCompleted`: `{ run_id, phase_number, passed, findings_count }` - Review gate closed

**Agent Team Orchestration:**
- `TeamCreated`: `{ run_id, team_id, strategy, isolation, plan_summary, tasks }` - Team initialized
- `WaveStarted`: `{ run_id, team_id, wave, task_ids }` - Wave of parallel tasks begins
- `WaveCompleted`: `{ run_id, team_id, wave, success_count, failed_count }` - Wave finishes
- `AgentTaskStarted`: `{ run_id, task_id, name, role, wave }` - Individual task starts
- `AgentTaskCompleted`: `{ run_id, task_id, success }` - Task succeeds
- `AgentTaskFailed`: `{ run_id, task_id, error }` - Task fails with error
- `AgentThinking`: `{ run_id, task_id, content }` - Agent thinking/planning
- `AgentAction`: `{ run_id, task_id, action_type, summary, metadata }` - Agent action taken
- `AgentOutput`: `{ run_id, task_id, content }` - Agent stdout/output
- `AgentSignal`: `{ run_id, task_id, signal_type, content }` - Signal (progress/blocker/pivot)

**Merge & Verification:**
- `MergeStarted`: `{ run_id, wave }` - Git merge begins
- `MergeCompleted`: `{ run_id, wave, conflicts }` - Merge succeeds/fails
- `MergeConflict`: `{ run_id, wave, files }` - Merge conflict detected
- `VerificationResult`: `{ run_id, task_id, verification_type, passed, summary, screenshots, details }`

**Other:**
- `ProjectCreated`: `{ project }` - New project created

**WebSocket Context (`contexts/WebSocketContext.tsx`):**
- Provider wraps app, establishes connection on mount
- Exponential backoff reconnect: 1s, 2s, 4s, ..., max 30s
- Pub/sub pattern: `subscribe(fn)` returns unsubscribe function
- All subscribers called on message arrival, errors caught and logged
- Exports: `WebSocketProvider`, `useWsSubscribe()`, `useWsStatus()`

**Connection Status Values:** `'connecting'` | `'connected'` | `'disconnected'`

---

### TYPESCRIPT TYPES (`ui/src/types/index.ts`)

**Core Data Models:**
- `Project`: id, name, path, github_repo (nullable), created_at
- `Issue`: id, project_id, title, description, column (IssueColumn), position, priority (Priority), labels[], github_issue_number (nullable), created_at, updated_at
- `PipelineRun`: id, issue_id, status (PipelineStatus), phase_count, current_phase, iteration, summary, error, branch_name, pr_url, team_id, has_team, started_at, completed_at
- `PipelineRunDetail` extends `PipelineRun`: + phases[]
- `IssueDetail`: issue + runs[]
- `BoardView`: project + columns[] (ColumnView[])
- `ColumnView`: name (IssueColumn) + issues[] (IssueWithStatus[])
- `IssueWithStatus`: issue + active_run (PipelineRun | null)
- `PipelinePhase`: id, run_id, phase_number, phase_name, status, iteration, budget, started_at, completed_at, error

**Agent Swarm Models:**
- `AgentTeam`: id, run_id, strategy (ExecutionStrategy), isolation (IsolationStrategy), plan_summary, created_at
- `AgentTask`: id, team_id, name, description, agent_role (AgentRole), wave, depends_on[], status (AgentTaskStatus), isolation_type, worktree_path, container_id, branch_name, started_at, completed_at, error
- `AgentEvent`: id, task_id, event_type (AgentEventType), content, metadata (any | null), created_at
- `AgentTeamDetail`: team + tasks[]

**Enums:**
- `IssueColumn`: 'backlog' | 'ready' | 'in_progress' | 'in_review' | 'done'
- `Priority`: 'low' | 'medium' | 'high' | 'critical'
- `PipelineStatus`: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled'
- `AgentTaskStatus`: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled'
- `AgentRole`: 'planner' | 'coder' | 'tester' | 'reviewer' | 'browser_verifier' | 'test_verifier'
- `AgentEventType`: 'thinking' | 'action' | 'output' | 'signal' | 'error'
- `ExecutionStrategy`: 'parallel' | 'sequential' | 'wave_pipeline' | 'adaptive'
- `IsolationStrategy`: 'worktree' | 'container' | 'hybrid' | 'shared'
- `SignalType`: 'progress' | 'blocker' | 'pivot'
- `VerificationType`: 'browser' | 'test_build'

**GitHub Models:**
- `GitHubDeviceCode`: device_code, user_code, verification_uri, expires_in, interval
- `GitHubRepo`: full_name, name, private, html_url, clone_url, description, default_branch
- `GitHubAuthStatus`: connected, client_id_configured
- `SyncResult`: imported, skipped, total_github

**UI Constants:**
- `COLUMNS[]`: Maps IssueColumn to display labels
- `PRIORITY_COLORS`: Map of Priority → Tailwind classes
- `STATUS_COLORS`: Map of PipelineStatus → Tailwind color classes

---

### ROUTING & PAGES

**Single-Page App Structure (no React Router):**
1. **ProjectSetup**: Initial screen when no projects exist or user clicks "Connect another project"
   - GitHub OAuth: Device flow (if client_id configured) or PAT input
   - Manual URL clone
   - Local path registration
   - Lists existing projects

2. **Main Board (after project selected):**
   - 5-column Kanban board (backlog, ready, in_progress, in_review, done)
   - Drag-drop between columns
   - Issue cards with pipeline status indicators
   - Play button to trigger pipelines

3. **Issue Detail Panel (modal on right side):**
   - Title editing (double-click to edit)
   - Priority, column, description, labels
   - Pipeline run history with phases
   - Branch/PR links
   - Run/Cancel/Delete buttons

---

### CORE COMPONENTS

**App.tsx (App root):**
- Wraps app in WebSocketProvider
- Manages selected project, selected issue, new issue form state
- Loads projects on mount
- Derives activeRunId from board state
- Handles GitHub connect dialog

**AppContent (Main logic):**
- State: projects[], selectedProject, selectedIssueId, showNewIssue, syncing
- Calls: useBoard(), useAgentTeam()
- Renders: Header, Board, IssueDetail, NewIssueForm, ProjectSetup, GitHubConnectDialog

**Header.tsx:**
- Project dropdown selector
- New Issue button
- Sync GitHub button (with spinner)
- WebSocket connection status indicator (green/yellow/red dot with text)

**Board.tsx:**
- @dnd-kit integration: DndContext + PointerSensor
- Renders 5 Column components
- On drag end: finds target column/position, calls onMoveIssue

**Column.tsx:**
- Droppable container with SortableContext (vertical list strategy)
- Renders issue count badge
- Special rendering:
  - **In Progress column:** Shows AgentTeamPanel (when team data exists)
  - **In Review column:** Shows IssueCard + VerificationPanel (when verification events exist)
  - **Other columns:** Standard IssueCard
- Elapsed time formatter: shows "1h 23m" for pipeline progress

**IssueCard.tsx:**
- Draggable with @dnd-kit sortable
- Shows: title, priority badge, GitHub issue number, labels, status icon
- Includes PlayButton (top-right corner)
- Progress bar when running/completed
- Hover/drag effects

**IssueDetail.tsx:**
- Right-side modal (fixed, 384px width)
- Title editable (double-click)
- Shows priority, column, description, labels
- Pipeline runs section with PhaseTimeline for each
- Run/Cancel/Delete action buttons
- Fetches data on mount, updates via manual API calls

**PlayButton.tsx:**
- Small floating button (28px circle) on IssueCard
- States: disabled (gray), loading (blue with spinner), ready (blue with play icon)
- Prevents bubbling, calls onTrigger(issueId)

**NewIssueForm.tsx:**
- Title input (required)
- Description textarea (optional)
- Cancel/Create buttons
- Auto-focus title on mount

**ProjectSetup.tsx:**
- Two tabs: GitHub, Local Path
- **GitHub tab:**
  - Device flow flow (if client_id configured): Shows code, polls for completion
  - OR PAT input: Requires `repo` scope
  - Connected state: Search repos, select, clone
  - Manual URL fallback
- **Local tab:**
  - Project name + absolute path inputs
- Lists existing projects at bottom
- Cleanup: clears polling interval on unmount

**PipelineStatus.tsx:**
- Compact or full size
- Shows icon (⏳/▶/✓/✗/⏹) + status text
- Spinner for running state
- Phase count display for running pipelines

**PhaseTimeline.tsx:**
- Renders phases with status icons, number, name
- Shows iteration/budget if available
- Shows duration (computed from started_at → completed_at)
- Scrollable, each phase on one line

**AgentTeamPanel.tsx:**
- Collapsible header with plan summary, elapsed time, agent count
- Displays progress bar (colors: red if failed, green if all completed, blue otherwise)
- Shows strategy + isolation + current wave
- Grouped by wave (marks parallel waves)
- Renders AgentCard for each task
- Defaults to expanded

**AgentCard.tsx:**
- Collapsible per-task card
- Header: status icon (with pulse animation if running), name, role badge, elapsed time
- Expanded view:
  - **Actions section:** Lists all "action" events, checkmarks/bullets
  - **Thinking section:** Latest thinking events
  - **Output section:** Scrollable terminal-style output (green text on black bg)
  - **Error section:** Red error box if task failed
- Auto-scrolls output to bottom when expanded
- Shows last action in header when collapsed

**VerificationPanel.tsx:**
- Shows test/build results (green/red box based on passed boolean)
- Shows browser verification results with thumbnails
- Screenshots clickable → full-screen modal
- Links to PR URL if available

**GitHubConnectDialog (in App.tsx):**
- Modal for connecting GitHub token
- Text input (password type) for PAT
- Link to GitHub token creation page
- Cancel/Connect buttons

---

### HOOKS

**useBoard(projectId):**
- Fetches board from `/projects/{id}/board`
- Subscribes to WebSocket messages:
  - `IssueCreated`, `IssueUpdated`, `IssueMoved`, `IssueDeleted` → update board state
  - `PipelineStarted`, `PipelineProgress`, `PipelineCompleted`, `PipelineFailed` → update active_run
  - `PipelineBranchCreated`, `PipelinePrCreated` → update run with branch_name/pr_url
- Optimistic moveIssue: Updates local state immediately, rolls back on error
- Exports: board, loading, error, moveIssue(), createIssue(), deleteIssue(), triggerPipeline(), refresh()

**useAgentTeam(activeRunId):**
- Fetches existing team data from `/runs/{id}/team` on mount (recovery after page refresh)
- Fetches all events for each task (for recovery)
- Subscribes to WebSocket messages:
  - `TeamCreated` → Initialize team and tasks
  - `AgentTaskStarted/Completed/Failed` → Update task status
  - `AgentThinking/Action/Output/Signal` → Append events to task's event list
  - `MergeStarted/Completed/Conflict` → Track merge state
  - `VerificationResult` → Store verification results
- Maintains: agentTeam, agentEvents (Map<taskId, AgentEvent[]>), mergeStatus, verificationResults
- Returns all above (verificationResults not currently displayed)

**useWebSocket(url):** (Legacy, not actively used)
- Direct WebSocket management (alternative to WebSocketProvider)
- Returns: lastMessage, connectionStatus, sendMessage()
- Exponential backoff reconnect

---

### STATE MANAGEMENT

**Pattern:** React hooks + WebSocket pub/sub (no Redux/Zustand)
- Component state via useState
- WebSocket subscription via custom context + useWsSubscribe hook
- API calls via async functions in event handlers
- Board state lifted to AppContent, derived for child components

**Data Flow:**
1. User action (drag, click button) → handler function
2. Handler calls API → optimistic update + API call
3. WebSocket updates propagate → state setters throughout tree
4. Re-renders cascade

---

### ERROR HANDLING

**API Errors:**
- `request()` throws on non-2xx; catches display error text
- Callers wrap in try/catch, set error state or display alert()

**WebSocket Errors:**
- Subscriber errors logged to console, don't crash app
- Connection errors trigger automatic reconnect with exponential backoff

**User-Facing Errors:**
- Alert dialogs for critical failures (sync, clone, etc.)
- Error state on Board component → red box display
- Console logs for recoverable errors (event fetch failures, etc.)

---

### HARDCODED VALUES / MAGIC STRINGS / TODOs

**Hardcoded Base URL:** `/api` in client.ts (line 1)

**Hardcoded WebSocket URL:** `ws://{window.location.host}/ws` in App.tsx (line 291)

**Magic Numbers:**
- Drag distance threshold: 8px (`activationConstraint: { distance: 8 }`)
- Pagination limit for task events: 100 (default in getTaskEvents)
- Max 30s exponential backoff for WS reconnect
- Polling interval for GitHub device flow: max(result.interval, 5) seconds

**UI Constants:**
- Column labels hardcoded in Column.tsx
- Role labels hardcoded in AgentCard.tsx
- Status styles (colors, icons) in AgentCard.tsx

**Incomplete Features:**
- verificationResults in useAgentTeam are not displayed (collected but unused)
- VerificationPanel expects screenshots at `/api/screenshots/{filename}` (endpoint not used elsewhere)
- Browser verify and test/build verification shown only in in_review column

**Environment Variables:**
- `API_HOST`: Controls backend target in vite config (defaults to 'localhost')

---

### USER INTERACTIONS SUMMARY

1. **Project Management:**
   - Create project (GitHub clone with OAuth or PAT, or local path)
   - Switch between projects
   - Sync GitHub issues into board

2. **Issue Management:**
   - Create issues in backlog
   - Edit issue title (double-click in detail panel)
   - View full issue details (click issue card)
   - Delete issues
   - Drag issues between columns

3. **Pipeline Execution:**
   - Trigger pipeline (play button on card or "Run Pipeline" in detail)
   - Cancel running pipeline
   - View phase timeline
   - View branch/PR links

4. **Agent Team Monitoring:**
   - Expand/collapse team panel to see task details
   - Expand/collapse individual agent cards
   - View thinking, actions, output in real-time

5. **Verification:**
   - View test/build results
   - View browser verification with screenshots
   - Click screenshots to enlarge

---

### TECH DEBT / OBSERVATIONS

1. **No form validation:** Project setup, new issue, title edit forms don't validate input beyond trimming
2. **Hardcoded URLs:** API path and WS URL are hardcoded; could be env vars
3. **No authentication layer:** All API calls assume auth is handled server-side
4. **No error boundaries:** App could crash if component throws
5. **Large useAgentTeam hook:** Could be split into smaller hooks (events, merge, verification)
6. **Manual event ID generation:** `Date.now()` for synthetic event IDs in WS handlers (could collide)
7. **No loading states for individual operations:** Only global board loading
8. **Screenshot endpoint:** `/api/screenshots/{src}` is hardcoded in VerificationPanel but no corresponding backend endpoint mentioned

---

### TESTING SETUP

- Vitest with React Testing Library
- MSW (Mock Service Worker) for API mocking
- Test files exist but content not deeply analyzed (test/fixtures.ts, test/handlers.ts, test/setup.ts, etc.)

---

### SUMMARY OF CRITICAL FLOWS

**Pipeline Trigger to Completion:**
1. User clicks play button → `triggerPipeline(issueId)`
2. POST `/issues/{id}/run` → PipelineRun returned
3. WebSocket `PipelineStarted` event → updates board's active_run
4. WebSocket `PipelineProgress` events → updates current_phase, iteration
5. WebSocket phase/agent events → displayed in AgentTeamPanel
6. WebSocket `PipelineCompleted` or `PipelineFailed` → final run status
7. User can view PhaseTimeline + branches/PRs in IssueDetail

**GitHub Sync:**
1. Click "Sync GitHub" button
2. Check `/github/status`
3. If not connected → show GitHubConnectDialog (PAT input)
4. POST `/github/connect` with token
5. POST `/projects/{id}/sync-github`
6. Board refreshes with new issues

---

This investigation covered all 47 source files in `ui/src/`, every API endpoint, all WebSocket message types, component hierarchy, hooks, state management, error handling, and user-facing features. The frontend is a real-time collaborative board with agent team orchestration visualization.
</teammate-message>

<teammate-message teammate_id="frontend-investigator" color="green">
{"type":"idle_notification","from":"frontend-investigator","timestamp":"2026-02-26T19:46:04.080Z","idleReason":"available"}
</teammate-message>

---

fix all 10 gaps using agent teams

---

Base directory for this skill: /Users/jdsingh/.claude/plugins/cache/claude-plugins-official/superpowers/4.3.1/skills/dispatching-parallel-agents

# Dispatching Parallel Agents

## Overview

When you have multiple unrelated failures (different test files, different subsystems, different bugs), investigating them sequentially wastes time. Each investigation is independent and can happen in parallel.

**Core principle:** Dispatch one agent per independent problem domain. Let them work concurrently.

## When to Use

```dot
digraph when_to_use {
    "Multiple failures?" [shape=diamond];
    "Are they independent?" [shape=diamond];
    "Single agent investigates all" [shape=box];
    "One agent per problem domain" [shape=box];
    "Can they work in parallel?" [shape=diamond];
    "Sequential agents" [shape=box];
    "Parallel dispatch" [shape=box];

    "Multiple failures?" -> "Are they independent?" [label="yes"];
    "Are they independent?" -> "Single agent investigates all" [label="no - related"];
    "Are they independent?" -> "Can they work in parallel?" [label="yes"];
    "Can they work in parallel?" -> "Parallel dispatch" [label="yes"];
    "Can they work in parallel?" -> "Sequential agents" [label="no - shared state"];
}
```

**Use when:**
- 3+ test files failing with different root causes
- Multiple subsystems broken independently
- Each problem can be understood without context from others
- No shared state between investigations

**Don't use when:**
- Failures are related (fix one might fix others)
- Need to understand full system state
- Agents would interfere with each other

## The Pattern

### 1. Identify Independent Domains

Group failures by what's broken:
- File A tests: Tool approval flow
- File B tests: Batch completion behavior
- File C tests: Abort functionality

Each domain is independent - fixing tool approval doesn't affect abort tests.

### 2. Create Focused Agent Tasks

Each agent gets:
- **Specific scope:** One test file or subsystem
- **Clear goal:** Make these tests pass
- **Constraints:** Don't change other code
- **Expected output:** Summary of what you found and fixed

### 3. Dispatch in Parallel

```typescript
// In Claude Code / AI environment
Task("Fix agent-tool-abort.test.ts failures")
Task("Fix batch-completion-behavior.test.ts failures")
Task("Fix tool-approval-race-conditions.test.ts failures")
// All three run concurrently
```

### 4. Review and Integrate

When agents return:
- Read each summary
- Verify fixes don't conflict
- Run full test suite
- Integrate all changes

## Agent Prompt Structure

Good agent prompts are:
1. **Focused** - One clear problem domain
2. **Self-contained** - All context needed to understand the problem
3. **Specific about output** - What should the agent return?

```markdown
Fix the 3 failing tests in src/agents/agent-tool-abort.test.ts:

1. "should abort tool with partial output capture" - expects 'interrupted at' in message
2. "should handle mixed completed and aborted tools" - fast tool aborted instead of completed
3. "should properly track pendingToolCount" - expects 3 results but gets 0

These are timing/race condition issues. Your task:

1. Read the test file and understand what each test verifies
2. Identify root cause - timing issues or actual bugs?
3. Fix by:
   - Replacing arbitrary timeouts with event-based waiting
   - Fixing bugs in abort implementation if found
   - Adjusting test expectations if testing changed behavior

Do NOT just increase timeouts - find the real issue.

Return: Summary of what you found and what you fixed.
```

## Common Mistakes

**❌ Too broad:** "Fix all the tests" - agent gets lost
**✅ Specific:** "Fix agent-tool-abort.test.ts" - focused scope

**❌ No context:** "Fix the race condition" - agent doesn't know where
**✅ Context:** Paste the error messages and test names

**❌ No constraints:** Agent might refactor everything
**✅ Constraints:** "Do NOT change production code" or "Fix tests only"

**❌ Vague output:** "Fix it" - you don't know what changed
**✅ Specific:** "Return summary of root cause and changes"

## When NOT to Use

**Related failures:** Fixing one might fix others - investigate together first
**Need full context:** Understanding requires seeing entire system
**Exploratory debugging:** You don't know what's broken yet
**Shared state:** Agents would interfere (editing same files, using same resources)

## Real Example from Session

**Scenario:** 6 test failures across 3 files after major refactoring

**Failures:**
- agent-tool-abort.test.ts: 3 failures (timing issues)
- batch-completion-behavior.test.ts: 2 failures (tools not executing)
- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)

**Decision:** Independent domains - abort logic separate from batch completion separate from race conditions

**Dispatch:**
```
Agent 1 → Fix agent-tool-abort.test.ts
Agent 2 → Fix batch-completion-behavior.test.ts
Agent 3 → Fix tool-approval-race-conditions.test.ts
```

**Results:**
- Agent 1: Replaced timeouts with event-based waiting
- Agent 2: Fixed event structure bug (threadId in wrong place)
- Agent 3: Added wait for async tool execution to complete

**Integration:** All fixes independent, no conflicts, full suite green

**Time saved:** 3 problems solved in parallel vs sequentially

## Key Benefits

1. **Parallelization** - Multiple investigations happen simultaneously
2. **Focus** - Each agent has narrow scope, less context to track
3. **Independence** - Agents don't interfere with each other
4. **Speed** - 3 problems solved in time of 1

## Verification

After agents return:
1. **Review each summary** - Understand what changed
2. **Check for conflicts** - Did agents edit same code?
3. **Run full suite** - Verify all fixes work together
4. **Spot check** - Agents can make systematic errors

## Real-World Impact

From debugging session (2025-10-03):
- 6 failures across 3 files
- 3 agents dispatched in parallel
- All investigations completed concurrently
- All fixes integrated successfully
- Zero conflicts between agent changes

---

<teammate-message teammate_id="app-fixes" color="yellow" summary="App.tsx WS URL + ProjectCreated fixes done">
Both fixes applied to `/Users/jdsingh/Projects/AI/forge/ui/src/App.tsx`:

**Gap 6 (WebSocket URL - HIGH):** Line 302 — Changed from hardcoded `ws://` to protocol-aware detection:
```typescript
const wsUrl = `${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`;
```

**Gap 4 (ProjectCreated WS - LOW):** Lines 106-115 — Added `useWsSubscribe` handler in `AppContent` that:
- Listens for `type === 'ProjectCreated'` messages
- Deduplicates by checking `prev.some(p => p.id === msg.data.project.id)`
- Appends new projects to state: `[...prev, msg.data.project]`
- Uses `useCallback` with stable empty deps, consistent with the codebase pattern (e.g., `useBoard.ts`)

Also imported `useWsSubscribe` from the WebSocket context (line 5).
</teammate-message>

<teammate-message teammate_id="app-fixes" color="yellow">
{"type":"idle_notification","from":"app-fixes","timestamp":"2026-02-27T05:49:50.361Z","idleReason":"available"}
</teammate-message>

---

<teammate-message teammate_id="system">
{"type":"teammate_terminated","message":"app-fixes has shut down."}
</teammate-message>

<teammate-message teammate_id="app-fixes" color="yellow">
{"type":"shutdown_approved","requestId":"shutdown-1772171457951@app-fixes","from":"app-fixes","timestamp":"2026-02-27T05:51:01.414Z","paneId":"in-process","backendType":"in-process"}
</teammate-message>

---

<teammate-message teammate_id="ws-handlers" color="blue" summary="Gap 1 and Gap 5 edits complete">
Done. All edits for Gap 1 (PipelineError) and Gap 5 (Review events) are complete across the three files:

**`ui/src/types/index.ts`:**
- Added `| { type: 'PipelineError'; data: { run_id: number; message: string } }` to `WsMessage` union (line 160)
- Added `review_status?: 'pending' | 'reviewing' | 'passed' | 'failed'` and `review_findings?: number` to `PipelinePhase` interface (lines 77-78)

**`ui/src/hooks/useBoard.ts`:**
- Added `PipelineError` handler: finds issue by `active_run.id === run_id` and sets `error: message` (lines 171-183)
- Added `PipelinePhaseStarted` handler: resets `review_status` and `review_findings` to `undefined` when a new phase starts (lines 185-197)
- Added `PipelinePhaseCompleted` handler: no-op passthrough (lines 199-201)
- Added `PipelineReviewStarted` handler: sets `review_status: 'reviewing'` on the matching run (lines 202-214)
- Added `PipelineReviewCompleted` handler: sets `review_status: 'passed'|'failed'` and `review_findings: findings_count` (lines 216-228)

**`ui/src/components/PhaseTimeline.tsx`:**
- Added review status display between phase name and duration info (lines 61-69):
  - `reviewing` -> yellow "Reviewing..." label
  - `passed` -> green "Review passed" label
  - `failed` -> amber "{N} finding(s)" label with pluralization
</teammate-message>

---

<teammate-message teammate_id="ws-handlers" color="blue">
{"type":"idle_notification","from":"ws-handlers","timestamp":"2026-02-27T05:51:10.418Z","idleReason":"available"}
</teammate-message>

<teammate-message teammate_id="system">
{"type":"teammate_terminated","message":"ws-handlers has shut down."}
</teammate-message>

<teammate-message teammate_id="ws-handlers" color="blue">
{"type":"shutdown_approved","requestId":"shutdown-1772171473068@ws-handlers","from":"ws-handlers","timestamp":"2026-02-27T05:51:17.201Z","paneId":"in-process","backendType":"in-process"}
</teammate-message>

---

<teammate-message teammate_id="agent-panel" color="purple" summary="Completed gaps 7 and 9 in AgentTeamPanel">
Done with gaps 7 and 9 in AgentTeamPanel. Here is a summary of what I changed:

**Files edited:**
1. `/Users/jdsingh/Projects/AI/forge/ui/src/components/AgentTeamPanel.tsx`
2. `/Users/jdsingh/Projects/AI/forge/ui/src/components/Column.tsx`

**Gap 9 — Merge conflict events (AgentTeamPanel.tsx):**
- Added `mergeStatus` and `verificationResults` as optional props to `AgentTeamPanelProps`
- Added a merge status section below the wave/task list inside the expanded area:
  - `started: true` shows a blue pulsing dot with "Merging wave N..."
  - `started: false, conflicts: false` shows a green "Merge complete" badge
  - `conflicts: true` shows a red "Merge conflict" badge plus a list of conflicting files from `conflictFiles`

**Gap 7 — Verification results during in_progress (AgentTeamPanel.tsx):**
- Added a "Verification" section below the merge status showing each `VerificationResult`:
  - SVG checkmark (green) or X (red) icon based on `passed`
  - Labels "Tests & Build" for `test_build` type, "Visual Verification" for `browser` type
  - Summary text for each result
  - Clickable screenshot thumbnails for browser-type results (using `/api/screenshots/{src}`)
  - Full-screen lightbox overlay when a thumbnail is clicked

**Column.tsx changes:**
- Added `mergeStatus` and `verificationResults` optional props to `ColumnProps`
- Passes them through to `AgentTeamPanel` in the `in_progress` column rendering

**Note:** The parent components (`Board.tsx` and `App.tsx`) still need to thread `mergeStatus` and `verificationResults` from `useAgentTeam` through to `Column`. Currently `App.tsx` line 91 destructures `useAgentTeam` but only extracts `agentTeam` and `agentEvents`. It needs to also extract `mergeStatus` and `verificationResults` and pass them through `Board -> Column`. This was outside the constraint scope for this task.

TypeScript compiles cleanly — `npx tsc --noEmit` passes with zero errors.
</teammate-message>

<teammate-message teammate_id="agent-panel" color="purple">
{"type":"idle_notification","from":"agent-panel","timestamp":"2026-02-27T05:57:34.716Z","idleReason":"available"}
</teammate-message>

---

<teammate-message teammate_id="agent-panel" color="purple">
{"type":"shutdown_approved","requestId":"shutdown-1772171885647@agent-panel","from":"agent-panel","timestamp":"2026-02-27T05:58:14.238Z","paneId":"in-process","backendType":"in-process"}
</teammate-message>

---

<teammate-message teammate_id="system">
{"type":"teammate_terminated","message":"agent-panel has shut down."}
</teammate-message>

---

<teammate-message teammate_id="issue-detail" color="green" summary="Gaps 2,3,8,10 complete: priority/labels/description editing, cancel confirm, poll type">
All gaps 2, 3, 8, and 10 are complete. Here is a summary of every change:

**Gap 2 — Priority & labels editable:**
- `src/factory/api.rs`: Added `priority: Option<String>` and `labels: Option<String>` to `UpdateIssueRequest`. Updated `update_issue` handler to pass both new fields through to the DB.
- `src/factory/db.rs`: Extended `update_issue()` method signature to accept `priority: Option<&str>` and `labels: Option<&str>`. Added SQL UPDATE statements for both columns matching existing pattern. Updated 3 test call sites to pass `None, None` for the new params.
- `ui/src/api/client.ts`: `updateIssue` now accepts `{ title?, description?, priority?, labels?: string[] }`. When labels are provided, they are stringified via `JSON.stringify` before sending.
- `ui/src/components/IssueDetail.tsx`: Priority badge replaced with a `<select>` dropdown (options: low, medium, high, critical). Labels section now shows chips with an "x" remove button and an inline text input to add new labels on Enter.

**Gap 3 — Description editable:**
- `ui/src/components/IssueDetail.tsx`: Description section now shows text by default. On click, switches to a `<textarea>`. Saves on blur or Ctrl+Enter. Shows "Click to edit" hint when empty. The description section now always renders (not just when non-empty).

**Gap 8 — Cancel confirmation:**
- `ui/src/components/IssueDetail.tsx`: Cancel button's onClick now wrapped in `window.confirm('Cancel this pipeline run? Running agents will be killed and in-progress work will be lost.')`.

**Gap 10 — Poll token response type:**
- `ui/src/api/client.ts`: `githubPollToken` return type changed from `{ status: 'pending' | 'complete' }` to `{ status: 'pending' | 'complete'; access_token?: string }`.

Note: There is a pre-existing compile error in `src/forge_config.rs` (conflicting `Deserialize` derive + manual impl on `PermissionMode`) that is unrelated to my changes.
</teammate-message>

---

lets commit this to a branch and create a PR